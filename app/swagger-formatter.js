var _ = require('lodash');
var log = function(msg) {
	//console.log(msg)
};

function SwaggerBuilder(types, apiKey) {
	this.swagger = {};
	this.types = types;
	this.apiKey = apiKey;
}

SwaggerBuilder.prototype.withInfo = function() {
	log('with info');
	this.swagger.swagger = '2.0';

	this.swagger.info = {
		description: 'This is an autogenerated API for a Telerik Backend Services application',
		version: '1.0.0',
		title: 'Backend Services API',
		contact: {
			email: 'cypressx@gmail.com'
		},
		license: {
			name: 'Apache 2.0',
			url: 'http://www.apache.org/licenses/LICENSE-2.0.html'
		}
	};

	return this;
};

SwaggerBuilder.prototype.withEverliveServer = function() {
	log('with everlive server');
	this.swagger.host = 'api.everlive.com';
	this.swagger.basePath = '/v1/' + this.apiKey;
	this.swagger.schemes = [
		'http'
	];

	return this;
};

SwaggerBuilder.prototype.makeFieldType = function(type, number) {
	return {
		type: type,
		number: number
	};
};

var dataTypes = {
	string: 1,
	double: 2,
	date: 3,
	boolean: 4
};

SwaggerBuilder.prototype.getEverliveFieldPropertyByDataType = function(dataType) {
	//https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#data-types
	switch (dataType) {
		case 1:
			return this.makeFieldType('string', 'string');
		case 2:
			return this.makeFieldType('double', 'double');
		case 3:
			return this.makeFieldType('string', 'date-time');
		case 4:
			return this.makeFieldType('boolean', null);
		default:
			return this.makeFieldType('string', 'string');
	}
};

SwaggerBuilder.prototype.getEverliveFieldProperty = function(field) {
	log('gettin everlive field property for data type = ' + field.DataType);
	var dataType = field.DataType;

	return this.getEverliveFieldPropertyByDataType(dataType);
};

SwaggerBuilder.prototype.getDeleteParameters = function() {
	return [{
		'name': 'filter',
		'in': 'query',
		'description': 'Specifies a filter expression.',
		'required': false,
		'type': 'string'
	}];
};

SwaggerBuilder.prototype.getQueryParameters = function() {
	return [{
		'name': 'filter',
		'in': 'query',
		'description': 'Specifies a filter expression.',
		'required': false,
		'type': 'string'
	}, {
		'name': 'fields',
		'in': 'query',
		'description': 'Select only a subset of the fields to be returned for each item.',
		'required': false,
		'type': 'string'
	}, {
		'name': 'sort',
		'in': 'query',
		'description': 'Order the items.',
		'required': false,
		'type': 'string'
	}, {
		'name': 'skip',
		'in': 'query',
		'description': 'Skip first N items.',
		'required': false,
		'type': 'integer'
	}, {
		'name': 'take',
		'in': 'query',
		'description': 'Take N items.',
		'required': false,
		'type': 'integer'
	}, {
		'name': 'singleField',
		'in': 'query',
		'description': 'Specifies a single item field to return instead of the whole item.',
		'required': false,
		'type': 'string'
	}, {
		'name': 'expand',
		'in': 'query',
		'description': 'Specifies an expand expression that defines what relations to expand',
		'required': false,
		'type': 'string'
	}, {
		'name': 'powerFields',
		'in': 'query',
		'description': 'Defines one or more power fields.',
		'required': false,
		'type': 'string'
	}, {
		'name': 'includeCount',
		'in': 'query',
		'description': 'Specifies whether to include the query result item count as an additional response value. Used for paging. Default value: TRUE.',
		'required': false,
		'type': 'boolean'
	}];
};

SwaggerBuilder.prototype.getSystemFields = function() {
	var systemFields = [
		{
			key: 'Id',
			value: this.getEverliveFieldPropertyByDataType(dataTypes.string) 
		},
		{
			key: 'CreatedAt',
			value: this.getEverliveFieldPropertyByDataType(dataTypes.date)
		},
		{
			key: 'ModifiedAt',
			value: this.getEverliveFieldPropertyByDataType(dataTypes.date)
		},
		{
			key: 'CreatedBy',
			value: this.getEverliveFieldPropertyByDataType(dataTypes.string)
		},
		{
			key: 'ModifiedBy',
			value: this.getEverliveFieldPropertyByDataType(dataTypes.string)
		}
	];
	return systemFields;
};

SwaggerBuilder.prototype.withDefinitions = function() {
	log('with definitions');
	var definitions = {};
	var paths = {};
	var self = this,
		queryParameters = this.getQueryParameters(),
		deleteParameters = this.getDeleteParameters(),
		systemFields = this.getSystemFields();

	_.each(this.types, function(type) {
		log('for type: ' + type.Name);
		var properties = {},
			getProperties = {};

		_.each(type.fields, function(field) {
			log('set for field: ' + field.Name);
			properties[field.Name] = self.getEverliveFieldProperty(field);
			getProperties[field.Name] = properties[field.Name];
		});

		// add system fields
		_.each(systemFields, function(systemField) {
			getProperties[ systemField.key ] = systemField.value;
		});

		definitions[type.Name] = {
			properties: properties
		};

		definitions['Get' + type.Name] = {
			properties: getProperties
		}
		definitions['Get' + type.Name + 'Response'] = {
			properties: {
				Count: self.getEverliveFieldPropertyByDataType(dataTypes.double),
				Result: {
					type: 'array',
					items: {
						$ref: '#/definitions/Get' + type.Name
					}
				}
			}
		};

		definitions['UpdateResult'] = {
			properties: {
				ModifiedAt: self.getEverliveFieldPropertyByDataType(dataTypes.date),
				Result: self.getEverliveFieldPropertyByDataType(dataTypes.double)
			}
		}

		paths['/' + type.Name] = {
			get: {
				tags: [
					type.Name
				],
				summary: 'Get ' + type.Name + ' items',
				description: '',
				operationId: 'get',
				consumes: [
					'application/json',
				],
				produces: [
					'application/json'
				],
				parameters: queryParameters,
				responses: {
					'200': {
						description: type.Name + ' response',
						schema: {
							$ref: '#/definitions/Get' + type.Name + 'Response'
						}
					},
					default: {
						description: 'error ocurred',
						schema: {
							$ref: '#/definitions/Error'
						}
					}
				}
			},
			put: {
				tags: [
					type.Name
				],
				produces: [
					'application/json'
				],
				operationId: 'update',
				parameters: [{
					name: type.Name,
					'in': 'body',
					'description': 'update object',
					'required': true
				}, deleteParameters[0]],
				responses: {
					'200': {
						description: type.Name + ' item updated.',
						schema: {
							$ref: '#/definitions/UpdateResult'
						}
					},
					default: {
						description: 'error ocurred',
						schema: {
							$ref: '#/definitions/Error'
						}
					}
				}
			},
			post: {
				tags: [
					type.Name
				],
				description: 'Creates a new ' + type.Name + ' item.',
				operationId: 'create',
				produces: [
					'application/json'
				],
				parameters: [{
					name: type.Name,
					'in': 'body',
					'description': 'to add',
					'required': true,
					schema: {
						'$ref': '#/definitions/' + type.Name
					}
				}],
				responses: {
					'201': {
						description: type.Name + ' item created.',
						schema: {
							$ref: '#/definitions/CreateResult'
						}
					},
					default: {
						description: 'error ocurred',
						schema: {
							$ref: '#/definitions/Error'
						}
					}
				}
			},
			delete: {
				tags: [
					type.Name
				],
				description: 'Delete from ' + type.Name,
				operationId: 'delete',
				parameters: deleteParameters,
				responses: {
					'200': {
						description: 'Items deleted.',
						schema: {
							$ref: '#/definitions/ResultScalar'
						}
					},
					default: {
						description: 'error ocurred',
						schema: {
							$ref: '#/definitions/Error'
						}
					}
				}
			}
		};

		paths['/' + type.Name + '/{id}'] = {
			get: {
				tags: [
					type.Name
				],
				summary: 'Get ' + type.Name + ' item by Id',
				description: '',
				operationId: 'getById',
				consumes: [
					'application/json',
				],
				produces: [
					'application/json'
				],
				'parameters': [{
					'name': 'id',
					'in': 'path',
					'description': 'ID of ' + type.Name + ' to fetch',
					'required': true,
					'type': 'string',
					'format': 'string'
				}],
				responses: {
					'200': {
						description: type.Name + ' response',
						schema: {
							$ref: '#/definitions/Get' + type.Name + 'Response'
						}
					},
					default: {
						description: 'error ocurred',
						schema: {
							$ref: '#/definitions/Error'
						}
					}
				}
			},
			put: {
				tags: [
					type.Name
				],
				produces: [
					'application/json'
				],
				operationId: 'updateById',
				'parameters': [{
					'name': 'id',
					'in': 'path',
					'description': 'ID of ' + type.Name + ' to fetch',
					'required': true,
					'type': 'string',
					'format': 'string'
				},
				{
					name: type.Name,
					'in': 'body',
					'description': 'update object',
					'required': true
				}],
				responses: {
					'200': {
						description: type.Name + ' item updated.',
						schema: {
							$ref: '#/definitions/UpdateResult'
						}
					},
					default: {
						description: 'error ocurred',
						schema: {
							$ref: '#/definitions/Error'
						}
					}
				}
			},
			delete: {
				tags: [
					type.Name
				],
				description: 'Delete from ' + type.Name + ' by Id.',
				operationId: 'deleteById',
				'parameters': [{
					'name': 'id',
					'in': 'path',
					'description': 'ID of ' + type.Name + ' to fetch',
					'required': true,
					'type': 'string',
					'format': 'string'
				}],
				responses: {
					'200': {
						description: 'Items deleted.',
						schema: {
							$ref: '#/definitions/ResultScalar'
						}
					},
					default: {
						description: 'error ocurred',
						schema: {
							$ref: '#/definitions/Error'
						}
					}
				}
			}
		};
	});

	definitions['Error'] = {
		required: [
			'errorCode',
			'message'
		],
		properties: {
			message: {
				type: 'string'
			},
			errorCode: {
				type: 'integer',
				format: 'int32'
			}
		}
	};

	definitions['CreateResult'] = {
		required: [
			'Result'
		],
		properties: {
			Result: {
				$ref: 'CreateResultObject'
			}
		}
	};

	definitions['CreateResultObject'] = {
		required: [
			'Id',
			'CreatedAt'
		],
		properties: {
			Id: {
				type: 'string'
			},
			CreatedAt: {
				type: 'date-time'
			}
		}
	};

	definitions['ResultScalar'] = {
		required: [
			'Result'
		],
		properties: {
			Result: {
				type: 'integer'
			}
		}
	}

	this.swagger.paths = paths;
	this.swagger.definitions = definitions;
	return this;
};

SwaggerBuilder.prototype.build = function() {
	log('build');
	return this.swagger;
};

var format = function(types, apiKey) {
	var swagger = new SwaggerBuilder(types, apiKey)
		.withInfo()
		.withEverliveServer()
		.withDefinitions()
		.build();

	return swagger;
};

exports.format = format;