var _ = require('lodash');
var log = function(msg) {
	//console.log(msg)
};

function SwaggerBuilder(types, apiKey) {
	this.swagger = {};
	this.types = types;
	this.apiKey = apiKey;
}

SwaggerBuilder.prototype.withInfo = function() {
	log('with info');
	this.swagger.swagger = '2.0';

	this.swagger.info = {
		description: 'This is an autogenerated api for a Telerik Backend Services application',
		version: '1.0.0',
		title: 'Backend Services API',
		contact: {
			email: 'cypressx@gmail.com'
		},
		license: {
			name: 'Apache 2.0',
			url: 'http://www.apache.org/licenses/LICENSE-2.0.html'
		}
	};

	return this;
};

SwaggerBuilder.prototype.withEverliveServer = function() {
	log('with everlive server');
	this.swagger.host = 'api.everlive.com';
	this.swagger.basePath = '/v1/' + this.apiKey;
	this.swagger.schemes = [
	'http'
		// TODO: https?
		];

		return this;
	};

	SwaggerBuilder.prototype.makeFieldType = function(type, number) {
		return { 
			type: type,
			number: number
		};
	};

	SwaggerBuilder.prototype.getEverliveFieldProperty = function(field) {
		log('gettin everlive field property for data type = ' + field.DataType);
		var dataType = field.DataType;

		//https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#data-types
		switch(dataType) {
			case 1:
			return this.makeFieldType('string', 'string');
			case 2:
			return this.makeFieldType('double', 'double');
			case 3:
			return this.makeFieldType('string', 'date-time');
			case 4:
			return this.makeFieldType('boolean', null);
			default:
			return this.makeFieldType('string', 'string');
		}
	};

	SwaggerBuilder.prototype.getDeleteParameters = function() {
		return [
		{
			'name': 'filter',
			'in': 'query',
			'description': 'Specifies a filter expression.',
			'required': false,
			'type': 'string'
		}];
	};

	SwaggerBuilder.prototype.getQueryParameters = function() {
		return [
		{
			'name': 'filter',
			'in': 'query',
			'description': 'Specifies a filter expression.',
			'required': false,
			'type': 'string'
		},
		{
			'name': 'fields',
			'in': 'query',
			'description': 'Select only a subset of the fields to be returned for each item.',
			'required': false,
			'type': 'string'
		},
		{
			'name': 'sort',
			'in': 'query',
			'description': 'Order the items.',
			'required': false,
			'type': 'string'
		},
		{
			'name': 'skip',
			'in': 'query',
			'description': 'Skip first N items.',
			'required': false,
			'type': 'integer'
		},
		{
			'name': 'take',
			'in': 'query',
			'description': 'Take N items.',
			'required': false,
			'type': 'integer'
		},
		{
			'name': 'singleField',
			'in': 'query',
			'description': 'Specifies a single item field to return instead of the whole item.',
			'required': false,
			'type': 'string'
		},
		{
			'name': 'expand',
			'in': 'query',
			'description': 'Specifies an expand expression that defines what relations to expand',
			'required': false,
			'type': 'string'
		},
		{
			'name': 'powerFields',
			'in': 'query',
			'description': 'Defines one or more power fields.',
			'required': false,
			'type': 'string'
		},
		{
			'name': 'includeCount',
			'in': 'query',
			'description': 'Specifies whether to include the query result item count as an additional response value. Used for paging. Default value: TRUE.',
			'required': false,
			'type': 'boolean'
		}	
		];
	};

	SwaggerBuilder.prototype.withDefinitions = function() {
		log('with definitions');
		var definitions = {};
		var paths = {};
		var self = this,
			queryParameters = this.getQueryParameters(),
			deleteParameters = this.getDeleteParameters();

		_.each(this.types, function(type) {
			log('for type: ' + type.Name);
			var properties = {};

			_.each(type.fields, function(field) {
				log('set for field: ' + field.Name);
				properties[ field.Name ] = self.getEverliveFieldProperty(field);
			});

			definitions[type.Name] = {
				properties: properties
			};

			paths['/' + type.Name] = {
				get: {
					tags: [
					type.Name
					],
					summary: 'Get ' + type.Name + ' items',
					description: '',
					operationId: 'get',
					consumes: [
					'application/json',
					],
					produces: [
					'application/json'
					],
					parameters: queryParameters,
					responses: {
						'200': {
							description: type.Name + ' response',
							schema: {
								$ref: '#/definitions/' + type.Name
							}
						},
						default: {
							description: 'error ocurred',
							schema: {
								$ref: '#/definitions/Error'
							}
						}
					}
				},
				post: {
					tags: [
						type.Name
					],
					description: 'Creates a new ' + type.Name + ' item.',
					operationId: 'create',
					produces: [
						'application/json'
					],
					parameters: [
						{
							name: type.Name,
							'in': 'body',
							'description': 'to add',
							'required': true,
							schema: {
								'$ref': '#/definitions/' + type.Name
							}
						}
					],
					responses: {
						'201': {
							description: type.Name + ' item created.',
							schema: {
								$ref: '#/definitions/CreateResult'
							}
						},
						default: {
							description: 'error ocurred',
							schema: {
								$ref: '#/definitions/Error'
							}
						}
					}
				},
				delete: {
					tags: [
						type.Name
					],
					description: 'Delete from ' + type.Name,
					operationId: 'delete',
					parameters: deleteParameters,
					responses: {
						'200': {
							description: 'Items deleted.',
							schema: {
								$ref: '#/definitions/ResultScalar'
							}
						},
						default: {
							description: 'error ocurred',
							schema: {
								$ref: '#/definitions/Error'
							}
						}
					}
				}
			};

			paths['/' + type.Name + '/{id}'] = {
				get: {
					tags: [
						type.Name
					],
					summary: 'Get ' + type.Name + ' item by Id',
					description: '',
					operationId: 'getById',
					consumes: [
					'application/json',
					],
					produces: [
					'application/json'
					],
					'parameters': [
			          {
			            'name': 'id',
			            'in': 'path',
			            'description': 'ID of ' + type.Name + ' to fetch',
			            'required': true,
			            'type': 'string',
			            'format': 'string'
			          }
			        ],
					responses: {
						'200': {
							description: type.Name + ' response',
							schema: {
								$ref: '#/definitions/' + type.Name
							}
						},
						default: {
							description: 'error ocurred',
							schema: {
								$ref: '#/definitions/Error'
							}
						}
					}
				},
				delete: {
					tags: [
						type.Name
					],
					description: 'Delete from ' + type.Name + ' by Id.',
					operationId: 'deleteById',
					'parameters': [
			          {
			            'name': 'id',
			            'in': 'path',
			            'description': 'ID of ' + type.Name + ' to fetch',
			            'required': true,
			            'type': 'string',
			            'format': 'string'
			          }
			        ],
					responses: {
						'200': {
							description: 'Items deleted.',
							schema: {
								$ref: '#/definitions/ResultScalar'
							}
						},
						default: {
							description: 'error ocurred',
							schema: {
								$ref: '#/definitions/Error'
							}
						}
					}
				}
		};
		});



	// TODO: Add Update
	// TODO: Add Get/Delete/Update by ID endpoints
	// TODO: add more detailed descriptions 

		definitions['Error'] = {
			required: [
			'errorCode',
			'message'
			],
			properties: {
				errorCode: {
					type: 'integer',
					format: 'int32'
				},
				message: {
					type: 'string'
				}
			}
		};

		definitions['CreateResult'] = {
			required: [
				'Result'
			],
			properties: {
				Result: {
					$ref: 'CreateResultObject'
				}
			}
		};

		definitions['CreateResultObject'] = {
			required: [
				'Id',
				'CreatedAt'
			],
			properties: {
				Id: {
					type: 'string'
				},
				CreatedAt: {
					type: 'date-time'
				}
			}
		};

		definitions['ResultScalar'] = {
			required: [
				'Result'
			],
			properties: {
				Result: {
					type: 'integer'
				}
			}
		}

		this.swagger.paths = paths;
		this.swagger.definitions = definitions;
		return this;
	};

	SwaggerBuilder.prototype.build = function() {
		log('build');
		return this.swagger;
	};

	var format = function(types, apiKey) {
		var swagger = new SwaggerBuilder(types, apiKey)
		.withInfo()
		.withEverliveServer()
		.withDefinitions()
		.build();

		return swagger;
	};

	exports.format = format;