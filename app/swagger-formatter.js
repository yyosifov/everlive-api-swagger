var _ = require('lodash');
var log = function(msg) {
	//console.log(msg);
};

function SwaggerBuilder(types, apiKey) {
	this.swagger = {};
	this.types = types;
	this.apiKey = apiKey;
}

SwaggerBuilder.prototype.withInfo = function() {
	log('with info');
	this.swagger.swagger = "2.0";

	this.swagger.info = {
		description: 'This is an autogenerated api for a Telerik Backend Services application',
		version: '1.0.0',
		title: 'Backend Services API',
		contact: {
			email: 'cypressx@gmail.com'
		},
		license: {
			name: 'Apache 2.0',
			url: 'http://www.apache.org/licenses/LICENSE-2.0.html'
		}
	};

	return this;
};

SwaggerBuilder.prototype.withEverliveServer = function() {
	log('with everlive server');
	this.swagger.host = 'api.everlive.com';
	this.swagger.basePath = '/v1/' + this.apiKey;
	this.swagger.schemes = [
	'http'
		// TODO: https?
		];

		return this;
	};

	SwaggerBuilder.prototype.makeFieldType = function(type, number) {
		return { 
			type: type,
			number: number
		};
	};

	SwaggerBuilder.prototype.getEverliveFieldProperty = function(field) {
		log('gettin everlive field property for data type = ' + field.DataType);
		var dataType = field.DataType;

		//https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#data-types
		switch(dataType) {
			case 1:
			return this.makeFieldType('string', 'string');
			case 2:
			return this.makeFieldType('double', 'double');
			case 3:
			return this.makeFieldType('string', 'date-time');
			case 4:
			return this.makeFieldType('boolean', null);
			default:
			return this.makeFieldType('string', 'string');
		}
	};

	SwaggerBuilder.prototype.getQueryParameters = function() {
		return [
		{
			"name": "filter",
			"in": "query",
			"description": "Specifies a filter expression.",
			"required": false,
			"type": "string"
		},
		{
			"name": "fields",
			"in": "query",
			"description": "Select only a subset of the fields to be returned for each item.",
			"required": false,
			"type": "string"
		},
		{
			"name": "sort",
			"in": "query",
			"description": "Order the items.",
			"required": false,
			"type": "string"
		},
		{
			"name": "skip",
			"in": "query",
			"description": "Skip first N items.",
			"required": false,
			"type": "integer"
		},
		{
			"name": "take",
			"in": "query",
			"description": "Take N items.",
			"required": false,
			"type": "integer"
		},
		{
			"name": "singleField",
			"in": "query",
			"description": "Specifies a single item field to return instead of the whole item.",
			"required": false,
			"type": "string"
		},
		{
			"name": "expand",
			"in": "query",
			"description": "Specifies an expand expression that defines what relations to expand",
			"required": false,
			"type": "string"
		},
		{
			"name": "powerFields",
			"in": "query",
			"description": "Defines one or more power fields.",
			"required": false,
			"type": "string"
		},
		{
			"name": "includeCount",
			"in": "query",
			"description": "Specifies whether to include the query result item count as an additional response value. Used for paging. Default value: TRUE.",
			"required": false,
			"type": "boolean"
		}	
		];
	};

	SwaggerBuilder.prototype.withDefinitions = function() {
		log('with definitions');
		var definitions = {};
		var paths = {};
		var self = this;

		_.each(this.types, function(type) {
			log('for type: ' + type.Name);
			var properties = {};

			_.each(type.fields, function(field) {
				log('set for field: ' + field.Name);
				properties[ field.Name ] = self.getEverliveFieldProperty(field);
			});

			definitions[type.Name] = {
				properties: properties
			};

			paths['/' + type.Name] = {
				get: {
					tags: [
					type.Name
					],
					summary: 'Get ' + type.Name + ' items',
					description: '',
					operationId: 'get',
					consumes: [
					"application/json",
					],
					produces: [
					"application/json"
					],
					parameters: self.getQueryParameters(),
					responses: {
						"200": {
							description: type.Name + ' response',
							schema: {
								$ref: '#/definitions/' + type.Name
							}
						},
						default: {
							description: "error ocurred",
							schema: {
								$ref: '#/definitions/Error'
							}
						}
					}
				},
				post: {
					description: 'Creates a new ' + type.Name + ' item.',
					produces: [
						'application/json'
					],
					parameters: [
						{
							name: type.Name,
							'in': 'body',
							'description': 'to add',
							'required': true,
							schema: {
								'$ref': '#/definitions/' + type.Name
							}
						}
					],
					responses: {
						"201": {
							description: type.Name + ' item created.',
							schema: {
								$ref: '#/definitions/CreateResult'
							}
						},
						default: {
							description: "error ocurred",
							schema: {
								$ref: '#/definitions/Error'
							}
						}
					}
				}
			};
		});

		definitions['Error'] = {
			required: [
			'errorCode',
			'message'
			],
			properties: {
				errorCode: {
					type: "integer",
					format: "int32"
				},
				message: {
					type: "string"
				}
			}
		};

		definitions['CreateResult'] = {
			required: [
				'Id',
				'CreatedAt'
			],
			properties: {
						Id: {
					type: 'string'
				},
				CreatedAt: {
					type: 'date-time'
				}

				//		$ref: '#/definitions/CreateResultObject'
				//}
			}
		};

		definitions['CreateResultObject'] = {
			required: [
				'Id',
				'CreatedAt'
			],
			properties: {
				Id: {
					type: 'string'
				},
				CreatedAt: {
					type: 'date-time'
				}
			}
		};

		this.swagger.paths = paths;
		this.swagger.definitions = definitions;
		return this;
	};

	SwaggerBuilder.prototype.build = function() {
		log('build');
		return this.swagger;
	};

	var format = function(types, apiKey) {
		var swagger = new SwaggerBuilder(types, apiKey)
		.withInfo()
		.withEverliveServer()
		.withDefinitions()
		.build();

		return swagger;
	};

	exports.format = format;